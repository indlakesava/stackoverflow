Master Big O Notation - Big-O cheat sheet

1. Two Pointers
 - Dual pointer strategy
 - Linear time complexity
 - Array/list problems

2. Sliding Window
 - Fixed/variable window
 - O(n) time optimization
 - Subarray/substring problems

3. Fast and Slow Pointer
 - Cycle detection method
 - O(1) space efficiency
 - Linked list problems

4. Merge Intervals
 - Sort and merge
 - O(n log n) complexity
 - Overlapping interval handling

5. Prefix Sum
 - Sum queries of subarrays
 - Pre computes prefix sums
 - Linear time complexity

6. Cyclic Sort
 - Sorting in cycles
 - O(n) time complexity
 - Constant space usage

7. In-place Reversal of Linked List
 - Reverse without extra space
 - O(n) time efficiency
 - Pointer manipulation technique

8. Top 'K' elements
 - Use heap/quickselect
 - O(n log k) time
 - Efficient selection problem

9. Monotonic Stack
 - Maintain increasing/decreasing stack
 - Optimized for range queries
 - O(n) time complexity

10. K-way Merge
 - Merge sorted lists
 - Min-heap based approach
 - O(n log k) complexity

11. Two Heaps
 - Max and min heaps
 - Median tracking efficiently
 - O(log n) insertions

12. Modified Binary Search
 - Search in variations
 - O(log n) time
 - Rotated/specialized arrays

13. 0/1 Knapsack (Dynamic Programming)
 - Choose or skip items
 - O(n * W) complexity
 - Maximize value selection

14. Unbounded Knapsack (Dynamic Programming)
 - Unlimited item choices
 - O(n * W) complexity
 - Multiple item selection

15. Binary Tree Traversal
 - Pre/In/Post Order Traversal
 - Traverses binary trees

16. Breadth First Search
 - Level-by-level traversal
 - Uses queue structure
 - Shortest path problems

17. Depth First Search
 - Recursive/backtracking approach
 - Uses stack (or recursion)
 - Tree/graph traversal

18. Islands (Matrix Traversal)
 - DFS/BFS traversal
 - Connected component detection
 - 2D grid problems

19. Subsets
 - Generate all subsets
 - Recursive or iterative
 - Backtracking or bitmasking

20. Topological Sort (Graphs)
 - Directed acyclic graph
 - Order dependency resolution
 - Uses DFS or BFS

21. Backtracking
 - Recursive decision-making
 - Explore all possibilities
 - Pruning with constraints

22. Dynamic Programming
 - Optimization problems
 - Puzzles, Permutations, Combinations

23. Bitwise XOR
 - Toggle bits operation
 - O(1) space complexity
 - Efficient for pairing


Resources
https://neetcode.io/practice - Core/75/150
https://takeuforward.org/interviews/strivers-sde-sheet-top-coding-interview-problems/
https://leetcode.com/studyplan/top-interview-150/
https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions
https://www.techinterviewhandbook.org/grind75
https://algo.monster/flowchart

Learning
Try to learn the patterns and how to identify, Make notes and revise
Decide the pattern in which you are planning to work through and stick to it making small corrections
Have Short term goals and write down the progress
Maintain a book, for each question, write down the thought process starting from when you viewed the qns, constraints, edge cases, attempts, failures, why it failed, what is the final answer, any additional ways to solve this
Keep reading others stories to motivate yourself

Useful Links
https://interviewguide.dev/
Sorting - https://medium.com/@Practicus-AI/a-tour-of-the-top-5-sorting-algorithms-with-python-code-43ea9aa02889
Binary Search Card - https://leetcode.com/explore/learn/card/binary-search/
Tree Basics - https://medium.com/the-renaissance-developer/learning-tree-data-structure-27c6bb363051
HackerEarth Tutorials - https://www.hackerearth.com/practice/algorithms/graphs/breadth-first-search/tutorial/
Dynamic Programming Patterns - https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns/439810
DP Approach - https://www.quora.com/Are-there-any-good-resources-or-tutorials-for-dynamic-programming-DP-besides-the-TopCoder-tutorial
LC questions to practice - https://leetcode.com/discuss/career/449135/How-to-effectively-use-LeetCode-to-prepare-for-interviews

Mock Interviews - https://www.pramp.com/#/
...
